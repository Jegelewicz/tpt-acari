problems <- not_in_taxo[not_in_taxo$taxonID %!in% htcol,] # get all rows in above that do not match  original higher geography (htcol)
}
rename_column <- function(dat,old,new,silent=FALSE){
if(old %in% colnames(dat)){
colnames(dat)[which(names(dat) == old)] <- new
} else {
if(!silent){
cat(paste("\nFieldname not found...",old))
}
}
return(dat)
}
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
warnings()
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # get GBIF higher taxa (DwC2taxo removes them, this is to check rows later)
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
# sanity check
original <- nrow(GBIF) # number of rows in cleaned file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
GBIF_problems <- GBIF_not_in_taxo[GBIF_not_in_taxo$taxonID %!in% GBIF_ht$taxonID,] # get all rows in above that do not match an id in GBIF_ht
GBIF_problems$taxonomicStatus <- NULL # status is the most likely issue, so NULL it
GBIF_problems_taxo <- DwC2taxo(problems, source = "GBIF") # transform problems to taxo format)
GBIF_taxo <- rbind(GBIF_taxo, GBIF_problems_taxo) # return converted problems to working file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
GBIF_ugh <- GBIF_problems[GBIF_problems$taxonID %!in% GBIF_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(GBIF_ugh,"~/GitHub/tpt-acari/output/GBIF_problems.csv", row.names = FALSE) # write out problems for review
}
}
GBIF_problems_taxo <- DwC2taxo(problems, source = "GBIF") # transform problems to taxo format)
GBIF_problems_taxo <- DwC2taxo(GBIF_problems, source = "GBIF") # transform problems to taxo format)
GBIF_taxo <- rbind(GBIF_taxo, GBIF_problems_taxo) # return converted problems to working file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
GBIF_ugh <- GBIF_problems[GBIF_problems$taxonID %!in% GBIF_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(GBIF_ugh,"~/GitHub/tpt-acari/output/GBIF_problems.csv", row.names = FALSE) # write out problems for review
}
View(GBIF_ugh)
# read in files
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned Acari Darwin Core file
Acari$taxonomicStatus <- NULL
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # NMNH higher taxa
Acari_taxo <- DwC2taxo(Acari, source = "TPT") # transform to taxotool format
# sanity check
original <- nrow(Acari) # number of rows in cleaned file
final <- nrow(Acari_taxo) + nrow(Acari_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
Acari_not_in_taxo <- Acari[Acari$taxonID %!in% Acari_taxo$id,] # get all rows in Acari that do not match an id in taxo
Acari_problems <- Acari_not_in_taxo[Acari_not_in_taxo$taxonID %!in% Acari_ht$taxonID,] # get all rows in above that do not match an id in Acari_ht
Acari_problems$taxonomicStatus <- NULL # status is the most likely issue, so NULL it
Acari_problems_taxo <- DwC2taxo(Acari_problems, source = "Acari") # transform problems to taxo format)
Acari_taxo <- rbind(Acari_taxo, Acari_problems_taxo) # return converted problems to working file
final <- nrow(Acari_taxo) + nrow(Acari_ht) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
Acari_ugh <- Acari_problems[Acari_problems$taxonID %!in% Acari_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(Acari_ugh,"~/GitHub/tpt-acari/output/Acari_problems.csv", row.names = FALSE) # write out problems for review
}
}
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo) # master is GBIF, merging with Acari
View(GBIF_taxo)
View(Acari)
View(Acari_taxo)
View(GBIF)
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE) # write out taxo file for review
write.csv(Acari_taxo,"~/GitHub/tpt-acari/output/Acari_taxo.csv", row.names = FALSE) # write out taxo file for review
library(readxl)
library(data.table)
library(stringi)
library(taxotools)
library(dplyr)
library(plyr)
# functions
# define function: name length
name_length <- function(x) ifelse(!is.na(x), length(unlist(strsplit(x, ' '))), 0)
# define function: is not in
'%!in%' <- function(x,y)!('%in%'(x,y))
# define function: right
right = function (string, char) {
substr(string,(unlist(lapply(gregexpr(pattern = char, string), min)) + 1),nchar(string))
}
# define function: left
left = function (string,char) {
substr(string,1,unlist(lapply(gregexpr(pattern = char, string), min)))
}
# define function: text to columns
text_to_columns <- function(dat, col, data="", column="", separator="", new_col_name_prefix="") { # dat is the data frame to operate on and col is the name of the column to be split
colno <- max(lengths(strsplit(col, separator))) # get max number of terms for any value in the column to be split
setDT(dat)[, paste0(new_col_name_prefix, 1:colno) := tstrsplit(col, separator)] # parse out terms into separate columns with column names prefixed with new_col_name_prefix plus consecutive numbers from 1 through colno
}
# function: remove '\xa0' chars
phrase_clean <- function(x) gsub("[\xA0]", "", x)
# function: replace double spaces with single spaces
space_clean <- function(x) gsub("  ", " ", x)
# function: get everything from INSIDE any parenthesis
inparens <- function(x)gsub("(?<=\\()[^()]*(?=\\))(*SKIP)(*F)|.", "", x, perl=T)
# function: get everything from OUTSIDE any parenthesis
outparens <- function(x){
trimws(gsub("\\([^()]*\\)", "", x))
}
# function: apply a function to ALL character columns
char_fun <- function(x,y){ # x = dataframe, y = function to apply
setDT(x)
cols_to_be_rectified <- names(x)[vapply(x, is.character, logical(1))]
x[,c(cols_to_be_rectified) := lapply(.SD, y), .SDcols = cols_to_be_rectified]
}
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*species.*', 'specificEpithet',x)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','author',x)
x <- gsub('.*year.*','namePublishedInYear',x)
x <- gsub('.*scientific.*','scientificName',x)
x
}
# define function: get higher taxa with epithets
higher_taxa_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(sp, name_length) == 0 &
lapply(spp, name_length) == 0),] # keep names where species and subspecies are blank
}
# define function: get higher taxa with rank
higher_taxa_rank <- function(dat, rank){ # dat is data frame, rank is column where taxon rank is given
dat[which(rank != "species" & # remove taxa ranked species
rank != "subspecies"),] # remove taxa ranked subspecies
}
# define function: get species with epithet
species_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(spp, name_length) != 0 | # keep taxa with a subspecies name
lapply(sp, name_length) != 0),] # keep taxa with a species name
}
# define function: get species with rank
species_rank <- function(dat, col){ # data is dataframe, col is column where rank is given
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),] # remove higher taxa from working file
dat[which(col == "species" | # keep taxa with rank species
col == "subspecies"),] # keep taxa ranked subspecies
}
# define function: find merge problems
merge_probs <- function(dat, datcol, taxocol, htcol){
not_in_taxo <- dat[datcol %!in% taxocol,] # get all rows in original data (dat) with (datcol) that does not match (taxocol)
problems <- not_in_taxo[not_in_taxo$taxonID %!in% htcol,] # get all rows in above that do not match  original higher geography (htcol)
}
rename_column <- function(dat,old,new,silent=FALSE){
if(old %in% colnames(dat)){
colnames(dat)[which(names(dat) == old)] <- new
} else {
if(!silent){
cat(paste("\nFieldname not found...",old))
}
}
return(dat)
}
# read in files
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned Acari Darwin Core file
Acari$taxonomicStatus <- NULL # Acari does not contain status, so NULL it
# read in files
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned Acari Darwin Core file
View(Acari)
Acari$taxonomicStatus <- NULL # Acari does not contain status, so NULL it
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # Acari higher taxa
Acari_taxo <- DwC2taxo(Acari, source = "TPT") # transform to taxotool format
# sanity check
original <- nrow(Acari) # number of rows in cleaned file
final <- nrow(Acari_taxo) + nrow(Acari_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) {
write.csv(Acari_taxo,"~/GitHub/tpt-acari/output/Acari_taxo.csv", row.names = FALSE) # write out taxo file for review
print("yay") # print yay if no rows are missing
} else {
Acari_not_in_taxo <- Acari[Acari$taxonID %!in% Acari_taxo$id,] # get all rows in Acari that do not match an id in taxo
Acari_problems <- Acari_not_in_taxo[Acari_not_in_taxo$taxonID %!in% Acari_ht$taxonID,] # get all rows in above that do not match an id in Acari_ht
Acari_problems$taxonomicStatus <- NULL # status is the most likely issue, so NULL it
Acari_problems_taxo <- DwC2taxo(Acari_problems, source = "Acari") # transform problems to taxo format)
Acari_taxo <- rbind(Acari_taxo, Acari_problems_taxo) # return converted problems to working file
final <- nrow(Acari_taxo) + nrow(Acari_ht) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
Acari_ugh <- Acari_problems[Acari_problems$taxonID %!in% Acari_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(Acari_ugh,"~/GitHub/tpt-acari/output/Acari_problems.csv", row.names = FALSE) # write out problems for review
}
}
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
View(GBIF)
warnings()
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF$class <- "Arachnida" # Acari file is missing class, add it
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # get GBIF higher taxa (DwC2taxo removes them, this is to check rows later)
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
# sanity check
original <- nrow(GBIF) # number of rows in cleaned file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) {
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE) # write out taxo file for review
print("yay") # print yay if no rows are missing
} else {
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
GBIF_problems <- GBIF_not_in_taxo[GBIF_not_in_taxo$taxonID %!in% GBIF_ht$taxonID,] # get all rows in above that do not match an id in GBIF_ht
GBIF_problems$taxonomicStatus <- NULL # status is the most likely issue, so NULL it
GBIF_problems_taxo <- DwC2taxo(GBIF_problems, source = "GBIF") # transform problems to taxo format)
GBIF_taxo <- rbind(GBIF_taxo, GBIF_problems_taxo) # return converted problems to working file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
GBIF_ugh <- GBIF_problems[GBIF_problems$taxonID %!in% GBIF_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(GBIF_ugh,"~/GitHub/tpt-acari/output/GBIF_problems.csv", row.names = FALSE) # write out problems for review
}
}
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo) # master is GBIF, merging with Acari
Mite_mast1 <- rbind.fill(GBIF_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo) # master is GBIF, merging with Acari
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE)
write.csv(Acari_taxo,"~/GitHub/tpt-acari/output/Acari_taxo.csv", row.names = FALSE)
View(Acari_taxo)
View(GBIF_taxo)
GBIF$ID <- as.numeric(GBIF$taxonID)
View(GBIF)
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF$class <- "Arachnida" # Acari file is missing class, add it
GBIF$atxonID <- as.numeric(GBIF$taxonID) # ensure that id column is numeric
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # get GBIF higher taxa (DwC2taxo removes them, this is to check rows later)
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
# sanity check
original <- nrow(GBIF) # number of rows in cleaned file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) {
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE) # write out taxo file for review
print("yay") # print yay if no rows are missing
} else {
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
GBIF_problems <- GBIF_not_in_taxo[GBIF_not_in_taxo$taxonID %!in% GBIF_ht$taxonID,] # get all rows in above that do not match an id in GBIF_ht
GBIF_problems$taxonomicStatus <- NULL # status is the most likely issue, so NULL it
GBIF_problems_taxo <- DwC2taxo(GBIF_problems, source = "GBIF") # transform problems to taxo format)
GBIF_taxo <- rbind(GBIF_taxo, GBIF_problems_taxo) # return converted problems to working file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
GBIF_ugh <- GBIF_problems[GBIF_problems$taxonID %!in% GBIF_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(GBIF_ugh,"~/GitHub/tpt-acari/output/GBIF_problems.csv", row.names = FALSE) # write out problems for review
}
}
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo) # master is GBIF, merging with Acari
View(GBIF_taxo)
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF$class <- "Arachnida" # Acari file is missing class, add it
GBIF$taxonID <- as.numeric(GBIF$taxonID) # ensure that id column is numeric
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # get GBIF higher taxa (DwC2taxo removes them, this is to check rows later)
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
View(GBIF_taxo)
# sanity check
original <- nrow(GBIF) # number of rows in cleaned file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) {
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE) # write out taxo file for review
print("yay") # print yay if no rows are missing
} else {
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
GBIF_problems <- GBIF_not_in_taxo[GBIF_not_in_taxo$taxonID %!in% GBIF_ht$taxonID,] # get all rows in above that do not match an id in GBIF_ht
GBIF_problems$taxonomicStatus <- NULL # status is the most likely issue, so NULL it
GBIF_problems_taxo <- DwC2taxo(GBIF_problems, source = "GBIF") # transform problems to taxo format)
GBIF_taxo <- rbind(GBIF_taxo, GBIF_problems_taxo) # return converted problems to working file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("yay") # print yay if no rows are missing
} else {
GBIF_ugh <- GBIF_problems[GBIF_problems$taxonID %!in% GBIF_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(GBIF_ugh,"~/GitHub/tpt-acari/output/GBIF_problems.csv", row.names = FALSE) # write out problems for review
}
}
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo) # master is GBIF, merging with Acari
Mite_mast1 <- rbind.fill(GBIF_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
Mite_mast1_1 <- cast_cs_field(Mite_mast1,"canonical","source")
View(GBIF_ugh)
# sanity check
taxo_acari <- rbindlist(list(Acari_taxo, GBIF_taxo), fill = TRUE) # combine all taxo files
acari_ht <- rbindlist(list(Acari_ht, GBIF_ht), fill = TRUE) # combine all ht files
original <- nrow(Acari) + nrow(GBIF) # get original number of rows in cleaned files
final <- nrow(taxo_acari) + nrow(acari_ht) # get final number of rows in converted taxo files and add to rows in higher taxa files
ifelse(original == final, write.csv(Mite_mast1_1,"~/GitHub/tpt-acari/output/taxo_acari.csv", row.names = FALSE), # if no rows are missing write taxo file
print("there are rows missing")) # if rows are missing, print error
write.csv(Mite_mast1_1,"~/GitHub/tpt-acari/output/taxo_Acari.csv", row.names = FALSE) # taxo file
devtools::install_github("vijaybarve/taxotools") # install latest version of taxotools from Github
library(readxl)
library(data.table)
library(stringi)
library(dplyr)
library(plyr)
library(devtools)
library(taxotools)
# functions
# define function: name length
name_length <- function(x) ifelse(!is.na(x), length(unlist(strsplit(x, ' '))), 0)
# define function: is not in
'%!in%' <- function(x,y)!('%in%'(x,y))
# define function: right
right = function (string, char) {
substr(string,(unlist(lapply(gregexpr(pattern = char, string), min)) + 1),nchar(string))
}
# define function: left
left = function (string,char) {
substr(string,1,unlist(lapply(gregexpr(pattern = char, string), min)))
}
# define function: text to columns
text_to_columns <- function(dat, col, data="", column="", separator="", new_col_name_prefix="") { # dat is the data frame to operate on and col is the name of the column to be split
colno <- max(lengths(strsplit(col, separator))) # get max number of terms for any value in the column to be split
setDT(dat)[, paste0(new_col_name_prefix, 1:colno) := tstrsplit(col, separator)] # parse out terms into separate columns with column names prefixed with new_col_name_prefix plus consecutive numbers from 1 through colno
}
# function: remove '\xa0' chars
phrase_clean <- function(x) gsub("[\xA0]", "", x)
# function: replace double spaces with single spaces
space_clean <- function(x) gsub("  ", " ", x)
# function: get everything from INSIDE any parenthesis
inparens <- function(x)gsub("(?<=\\()[^()]*(?=\\))(*SKIP)(*F)|.", "", x, perl=T)
# function: get everything from OUTSIDE any parenthesis
outparens <- function(x){
trimws(gsub("\\([^()]*\\)", "", x))
}
# function: apply a function to ALL character columns
char_fun <- function(x,y){ # x = dataframe, y = function to apply
setDT(x)
cols_to_be_rectified <- names(x)[vapply(x, is.character, logical(1))]
x[,c(cols_to_be_rectified) := lapply(.SD, y), .SDcols = cols_to_be_rectified]
}
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*species.*', 'specificEpithet',x)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','author',x)
x <- gsub('.*year.*','namePublishedInYear',x)
x <- gsub('.*scientific.*','scientificName',x)
x
}
# define function: get higher taxa with epithets
higher_taxa_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(sp, name_length) == 0 &
lapply(spp, name_length) == 0),] # keep names where species and subspecies are blank
}
# define function: get higher taxa with rank
higher_taxa_rank <- function(dat, rank){ # dat is data frame, rank is column where taxon rank is given
dat[which(rank != "species" & # remove taxa ranked species
rank != "subspecies"),] # remove taxa ranked subspecies
}
# define function: get species with epithet
species_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(spp, name_length) != 0 | # keep taxa with a subspecies name
lapply(sp, name_length) != 0),] # keep taxa with a species name
}
# define function: get species with rank
species_rank <- function(dat, col){ # data is dataframe, col is column where rank is given
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),] # remove higher taxa from working file
dat[which(col == "species" | # keep taxa with rank species
col == "subspecies"),] # keep taxa ranked subspecies
}
# define function: find merge problems
merge_probs <- function(dat, datcol, taxocol, htcol){
not_in_taxo <- dat[datcol %!in% taxocol,] # get all rows in original data (dat) with (datcol) that does not match (taxocol)
problems <- not_in_taxo[not_in_taxo$taxonID %!in% htcol,] # get all rows in above that do not match  original higher geography (htcol)
}
rename_column <- function(dat,old,new,silent=FALSE){
if(old %in% colnames(dat)){
colnames(dat)[which(names(dat) == old)] <- new
} else {
if(!silent){
cat(paste("\nFieldname not found...",old))
}
}
return(dat)
}
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo, "merged") # master is GBIF, merging with Acari
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF$class <- "Arachnida" # Acari file is missing class, add it
GBIF$taxonID <- as.numeric(GBIF$taxonID) # ensure that id column is numeric
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # get GBIF higher taxa (DwC2taxo removes them, this is to check rows later)
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
Acari$taxonomicStatus <- NULL # Acari does not contain status, so NULL it
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # Acari higher taxa
Acari_taxo <- DwC2taxo(Acari, source = "TPT") # transform to taxotool format
# Acari taxo conversion
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned Acari Darwin Core file
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo, "merged") # master is GBIF, merging with Acari
Acari$taxonomicStatus <- NULL # Acari does not contain status, so NULL it
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # Acari higher taxa
Acari_taxo <- DwC2taxo(Acari, source = "TPT") # transform to taxotool format
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo, "merged") # master is GBIF, merging with Acari
# sanity check
taxo_acari <- rbindlist(list(Acari_taxo, GBIF_taxo), fill = TRUE) # combine all taxo files
acari_ht <- rbindlist(list(Acari_ht, GBIF_ht), fill = TRUE) # combine all ht files
original <- nrow(Acari) + nrow(GBIF) # get original number of rows in cleaned files
final <- nrow(taxo_acari) + nrow(acari_ht) # get final number of rows in converted taxo files and add to rows in higher taxa files
final <- nrow(taxo_acari) + nrow(acari_ht) + acari_ht # get final number of rows in converted taxo files and add to rows in higher taxa files
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
GBIF_problems <- GBIF_not_in_taxo[GBIF_not_in_taxo$taxonID %!in% GBIF_ht$taxonID,] # get all rows in above that do not match an id in GBIF_ht
View(GBIF_problems)
View(GBIF_not_in_taxo)
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF", statuslist="Accepted", "Synonym", "Valid", "heterotypicSynonym",
"homotypicSynonym", "doubtful", "proparte synonym", "misapplied") # transform to taxo format
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF", statuslist = c("Accepted", "Synonym", "Valid", "heterotypicSynonym",
"homotypicSynonym", "doubtful", "proparte synonym", "misapplied")) # transform to taxo format
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
View(GBIF_not_in_taxo)
# sanity check
original <- nrow(GBIF) # number of rows in cleaned file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) {
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE) # write out taxo file for review
print("yay") # print yay if no rows are missing
} else {
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) + nrow(GBIF_not_in_taxo) # recalculate number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) { print("rows are missing") # print yay if no rows are missing
} else {
GBIF_ugh <- GBIF_problems[GBIF_problems$taxonID %!in% GBIF_problems_taxo$id,] # get all rows in taxo that do not match an id in problems
write.csv(GBIF_ugh,"~/GitHub/tpt-acari/output/GBIF_problems.csv", row.names = FALSE) # write out problems for review
}
}
if(original == final) {
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE) # write out taxo file for review
print("yay") # print yay if no rows are missing
} else {
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
print("rows are missing") # print yay if no rows are missing
}
# sanity check
original <- nrow(GBIF) # number of rows in cleaned file
final <- nrow(GBIF_taxo) + nrow(GBIF_ht) # number of rows in converted taxo file plus number of rows in higher taxa
if(original == final) {
write.csv(GBIF_taxo,"~/GitHub/tpt-acari/output/GBIF_taxo.csv", row.names = FALSE) # write out taxo file for review
print("yay") # print yay if no rows are missing
} else {
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
print("rows are missing") # print yay if no rows are missing
}
# taxo Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo, "all") # master is GBIF, merging with Acari
GBIF <- GBIF[which(GBIF$order != "Ixodida"),]
View(GBIF)
View(Mite_m1)
View(taxo_acari)
Acari_checklist <- taxo2doc(Mite_m1,
mastersource="GBIF",
duplicatesyn=FALSE,
outformat="html_document",
outdir="C:/Users/Teresa/OneDrive/Documents/GitHub/tpt-acari/output/",outfile="Mite_taxolist.html")
View(GBIF_not_in_taxo)
View(GBIF_not_in_taxo)
View(GBIF_problems)
View(GBIF_taxo)
View(Mite_m1)
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF$class <- "Arachnida" # Acari file is missing class, add it
GBIF$taxonID <- as.numeric(GBIF$taxonID) # ensure that id column is numeric
GBIF <- GBIF[which(GBIF$order != "Ixodida"),]
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF$class <- "Arachnida" # Acari file is missing class, add it
GBIF$taxonID <- as.numeric(GBIF$taxonID) # ensure that id column is numeric
# GBIF taxo conversion
GBIF <- read_excel("~/GitHub/tpt-acari/input/GBIF_acari.xlsx") # read in GBIF file
GBIF$class <- "Arachnida" # Acari file is missing class, add it
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF$taxonID <- as.numeric(GBIF$taxonID) # ensure that id column is numeric
GBIF_Ixodida <- GBIF[which(GBIF$order == "Ixodida"),]
GBIF <- GBIF[which(GBIF$order != "Ixodida"),]
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # get GBIF higher taxa (DwC2taxo removes them, this is to check rows later)
# check for duplicate names
duplicates <- GBIF[which(duplicated(GBIF$canonical)),]
View(GBIF)
View(GBIF_Ixodida)
# check for duplicate names
duplicates <- GBIF[which(duplicated(GBIF$canonicalName)),]
View(duplicates)
View(GBIF)
View(duplicates)
# check for duplicate names
GBIF$dupe_dataset <- c(ifelse(duplicated(GBIF$canonicalName, fromLast = TRUE)  | duplicated(GBIF$canonicalName),
"GBIF", NA)) # Flag internal dupes
GBIF_dupes_review <- GBIF[which(grepl('GBIF',GBIF$dupe_dataset) == TRUE), ]  # get duplicates for review
GBIF <- GBIF[which(grepl('GBIF',GBIF$dupe_dataset) == FALSE), ] # remove all dupes from working file
write.csv(GBIF_dupes_review,"~/GitHub/tpt-acari/output/GBIF_duplicates.csv", row.names = FALSE) # write out duplicates file for review
