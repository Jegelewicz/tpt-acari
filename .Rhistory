# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*species.*', 'specificEpithet',x)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','author',x)
x <- gsub('.*year.*','namePublishedInYear',x)
x <- gsub('.*scientific.*','scientificName',x)
x
}
df <- mite_may_2020 # change filename for ease of use
original_rows <- nrow(df)
tpt_dwc_template <- read_excel("input/tpt_dwc_template.xlsx") # read in TPT DarwinCore template
tpt_dwc_template[] <- lapply(tpt_dwc_template, as.character) # set all columns in template to character
# transform column headers
colnames(df) <- tolower(colnames(df)) # lower case column names
colnames(df) <- convert2DwC(colnames(df)) # convert to DarwinCore terms
df <- rbindlist(list(df, tpt_dwc_template), fill = TRUE) # add all DwC columns
df$source <- "UMZM" # add dataset name
df$taxonID <- seq.int(nrow(df)) # add numeric ID for each name
df$kingdom <- "Animalia" # add kingdom
df$phylum <- "Arthropoda" # add phylum
df <- char_fun(df,phrase_clean) # remove xa0 characters
df <- char_fun(df,trimws) # trim white space
df <- char_fun(df,space_clean) # change double spaces to single
# cast canonical name
df$canonicalName <- NA # create column for canonicalName
# extract higher taxa for next set of review
higher_taxa <- df[which(lapply(df$infraspecificEpithet, name_length) == 0 & lapply(df$specificEpithet, name_length) == 0),]
View(higher_taxa)
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),]
# generate canonical name for species and below
df <- cast_canonical(df,
canonical="canonicalName",
genus = "genus",
species = "specificEpithet",
subspecies = "infraspecificEpithet")
# generate taxonRank for species and below
for(i in 1:nrow(df)){
df$taxonRank[i] <-
ifelse(!is.na(df$infraspecificEpithet[i]), "subspecies",
ifelse(!is.na(df$specificEpithet[i]), "species",
"review"))
}
# canonical names for taxa ranked subgenus and above - get the lowest ranking term and put it here!
for(i in 1:nrow(higher_taxa)){
higher_taxa$canonicalName[i] <- ifelse(!is.na(higher_taxa$subgenus[i]), paste(higher_taxa$subgenus[i]),
ifelse(!is.na(higher_taxa$genus[i]), paste(higher_taxa$genus[i]),
ifelse(!is.na(higher_taxa$subtribe[i]), paste(higher_taxa$subtribe[i]),
ifelse(!is.na(higher_taxa$tribe[i]), paste(higher_taxa$tribe[i]),
ifelse(!is.na(higher_taxa$subfamily[i]), paste(higher_taxa$subfamily[i]),
ifelse(!is.na(higher_taxa$family[i]), paste(higher_taxa$family[i]),
ifelse(!is.na(higher_taxa$superfamily[i]), paste(higher_taxa$superfamily[i]),
ifelse(!is.na(higher_taxa$hyporder[i]), paste(higher_taxa$hyporder[i]),
ifelse(!is.na(higher_taxa$infraorder[i]), paste(higher_taxa$infraorder[i]),
ifelse(!is.na(higher_taxa$suborder[i]), paste(higher_taxa$suborder[i]),
ifelse(!is.na(higher_taxa$order[i]), paste(higher_taxa$order[i]),
ifelse(!is.na(higher_taxa$superorder[i]), paste(higher_taxa$superorder[i]),
ifelse(!is.na(higher_taxa$subclass[i]), paste(higher_taxa$subclass[i]),
ifelse(!is.na(higher_taxa$class[i]), paste(higher_taxa$class[i]),
ifelse(!is.na(higher_taxa$phylum[i]), paste(higher_taxa$phylum[i]),
ifelse(!is.na(higher_taxa$kingdom[i]), paste(higher_taxa$kingdom[i]), "review"))))))))))))))))
}
# generate taxonRank for subgenus and above
for(i in 1:nrow(higher_taxa)){
higher_taxa$taxonRank[i] <-
ifelse(!is.na(higher_taxa$subgenus[i]), "subgenus",
ifelse(!is.na(higher_taxa$genus[i]), "genus",
ifelse(!is.na(higher_taxa$subtribe[i]), "subtribe",
ifelse(!is.na(higher_taxa$tribe[i]), "tribe",
ifelse(!is.na(higher_taxa$subfamily[i]), "subfamily",
ifelse(!is.na(higher_taxa$family[i]), "family",
ifelse(!is.na(higher_taxa$superfamily[i]), "superfamily",
ifelse(!is.na(higher_taxa$hyporder[i]), "hyporder",
ifelse(!is.na(higher_taxa$infraorder[i]), "infraorder",
ifelse(!is.na(higher_taxa$suborder[i]), "suborder",
ifelse(!is.na(higher_taxa$order[i]), "order",
ifelse(!is.na(higher_taxa$superorder[i]), "superorder",
ifelse(!is.na(higher_taxa$subclass[i]), "subclass",
ifelse(!is.na(higher_taxa$class[i]), "class",
ifelse(!is.na(higher_taxa$phylum[i]), "phylum",
ifelse(!is.na(higher_taxa$kingdom[i]), "kingdom",
"review"))))))))))))))))
}
# cast scientific name for species and below
df$scientificName[i] <- for(i in 1:nrow(df)){
if(!is.na(df$genus[i])){
scn <- df$genus[i]
}
if(!is.na(df$subgenus[i])){
scn <- paste(scn," (",df$subgenus[i],")",sep = "")
}
if(!is.na(df$specificEpithet[i])){
scn <- paste(scn,df$specificEpithet[i], sep = " ")
}
if(!is.na(df$infraspecificEpithet[i])){
scn <- paste(scn,df$infraspecificEpithet[i], sep = " ")
}
if(!is.na(df$scientificNameAuthorship[i])){
scn <- paste(scn,trimws(df$scientificNameAuthorship[i]), sep = " ")
}
df$scientificName[i] <- scn
}
# cast scientific name for genus and above
higher_taxa$scientificName <- ifelse(is.na(higher_taxa$scientificNameAuthorship), higher_taxa$canonicalName, paste(higher_taxa$canonicalName, higher_taxa$scientificNameAuthorship, sep = " "))
# Extract rows from higher taxa that need review
flag <- c('review')
review_canonical <- higher_taxa[(higher_taxa$canonical %in% flag), ]
if(nrow(review_canonical) == 0){
print('No canonical names in higher_taxa have been flagged for review. Proceed to deduplication.')
df <- rbind(higher_taxa, df) # add higher taxa back to df for remainder of de-duplication
} else{
write.csv(review_canonical,"~/GitHub/tpt-acari/output/review_canonical.csv", row.names = FALSE) # these need review
higher_taxa <- higher_taxa[(higher_taxa$canonical %!in% flag), ] # extract review items from higher_taxa
stop('Open the review_canonical file in the output folder, make adjustments as appropriate and save the revised file to input as reviewed_canonical.xlsx before proceeding')
# after review add back cleaned up names
reviewed_canonical <- read_excel("input/reviewed_canonical.xlsx") # read in cleaned review file
higher_taxa <- rbind(higher_taxa, reviewed_canonical) # add reviewed higher_taxa back to the working file
df <- rbind(higher_taxa, df) # add higher taxa back to df for remainder of de-duplication
}
# order column names
#df[,c(1,2,3,4)]. Note the first comma means keep all the rows, and the 1,2,3,4 refers to the columns.
df <- df[,c("source",
"taxonID",
"scientificNameID",
"acceptedNameUsageID",
"parentNameUsageID",
"originalNameUsageID",
"nameAccordingToID",
"namePublishedInID",
"taxonConceptID",
"scientificName",
"acceptedNameUsage",
"parentNameUsage",
"originalNameUsage",
"nameAccordingTo",
"namePublishedIn",
"namePublishedInYear",
"higherClassification",
"kingdom",
"phylum",
"class",
"subclass",
"superorder",
"order",
"suborder",
"infraorder",
"hyporder",
"superfamily",
"family",
"subfamily",
"tribe",
"subtribe",
"genus",
"subgenus",
"specificEpithet",
"infraspecificEpithet",
"taxonRank",
"verbatimTaxonRank",
"scientificNameAuthorship",
"vernacularName",
"nomenclaturalCode",
"taxonomicStatus",
"nomenclaturalStatus",
"taxonRemarks",
"canonicalName"
)]
# review for duplicates
dupe <- df[,c('canonicalName')] # select columns to check duplicates
review_dups <- df[duplicated(dupe) | duplicated(dupe, fromLast=TRUE),]
write.csv(df,"~/GitHub/tpt-acari/output/UMZM_Acari.csv", row.names = FALSE) # ready for analysis
write.csv(df,"~/GitHub/tpt-acari/output/UMZM_Acari.csv", row.names = FALSE) # ready for analysis
write.csv(df,"~/GitHub/tpt-acari/output/Acari_DwC.csv", row.names = FALSE) # ready for analysis
# read in files
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned NMNH review file # NMNH higher taxa
View(Acari)
Acari$taxonomicStatus <- NULL
# Acari$taxonomicStatus <- ifelse(is.na(Acari$taxonomicStatus),"undefined",NMNH$taxonomicStatus) # fill in taxonomic status
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # NMNH higher taxa
# Acari_species <- species_rank(Acari, Acari$taxonRank) # NMNH species taxa
Acari_taxo <- DwC2taxo(Acari, source = "UMZM") # transform to taxotool format
# Acari_species <- species_rank(Acari, Acari$taxonRank) # NMNH species taxa
taxo_acari <- DwC2taxo(Acari, source = "UMZM") # transform to taxotool format
#sanity check
original <- nrow(Acari)
final <- nrow(taxo_acari) + nrow(Acari_ht)
ifelse(original == final, print("yay"),print("ugh"))
# if yay write out the taxo file
write.csv(df,"~/GitHub/tpt-acari/output/taxo_Acari.csv", row.names = FALSE) # taxo file
# libraries and functions used in this project
# libraries
library(readxl)
library(data.table)
library(stringi)
library(taxotools)
library(dplyr)
# functions
# define function: name length
name_length <- function(x) ifelse(!is.na(x), length(unlist(strsplit(x, ' '))), 0)
# define function: is not in
'%!in%' <- function(x,y)!('%in%'(x,y))
# define function: right
right = function (string, char) {
substr(string,(unlist(lapply(gregexpr(pattern = char, string), min)) + 1),nchar(string))
}
# define function: left
left = function (string,char) {
substr(string,1,unlist(lapply(gregexpr(pattern = char, string), min)))
}
# define function: text to columns
text_to_columns <- function(dat, col, data="", column="", separator="", new_col_name_prefix="") { # dat is the data frame to operate on and col is the name of the column to be split
colno <- max(lengths(strsplit(col, separator))) # get max number of terms for any value in the column to be split
setDT(dat)[, paste0(new_col_name_prefix, 1:colno) := tstrsplit(col, separator)] # parse out terms into separate columns with column names prefixed with new_col_name_prefix plus consecutive numbers from 1 through colno
}
# function: remove '\xa0' chars
phrase_clean <- function(x) gsub("[\xA0]", "", x)
# function: replace double spaces with single spaces
space_clean <- function(x) gsub("  ", " ", x)
# function: get everything from INSIDE any parenthesis
inparens <- function(x)gsub("(?<=\\()[^()]*(?=\\))(*SKIP)(*F)|.", "", x, perl=T)
# function: get everything from OUTSIDE any parenthesis
outparens <- function(x){
trimws(gsub("\\([^()]*\\)", "", x))
}
# function: apply a function to ALL character columns
char_fun <- function(x,y){ # x = dataframe, y = function to apply
setDT(x)
cols_to_be_rectified <- names(x)[vapply(x, is.character, logical(1))]
x[,c(cols_to_be_rectified) := lapply(.SD, y), .SDcols = cols_to_be_rectified]
}
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*species.*', 'specificEpithet',x)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','author',x)
x <- gsub('.*year.*','namePublishedInYear',x)
x <- gsub('.*scientific.*','scientificName',x)
x
}
# define function: get higher taxa with epithets
higher_taxa_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(sp, name_length) == 0 &
lapply(spp, name_length) == 0),] # keep names where species and subspecies are blank
}
# define function: get higher taxa with rank
higher_taxa_rank <- function(dat, rank){ # dat is data frame, rank is column where taxon rank is given
dat[which(rank != "species" & # remove taxa ranked species
rank != "subspecies"),] # remove taxa ranked subspecies
}
# define function: get species with epithet
species_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(spp, name_length) != 0 | # keep taxa with a subspecies name
lapply(sp, name_length) != 0),] # keep taxa with a species name
}
# define function: get species with rank
species_rank <- function(dat, col){ # data is dataframe, col is column where rank is given
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),] # remove higher taxa from working file
dat[which(col == "species" | # keep taxa with rank species
col == "subspecies"),] # keep taxa ranked subspecies
}
# read in files
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned Acari Darwin Core file
Acari$taxonomicStatus <- NULL
# Acari$taxonomicStatus <- ifelse(is.na(Acari$taxonomicStatus),"undefined",NMNH$taxonomicStatus) # fill in taxonomic status
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # NMNH higher taxa
# Acari_species <- species_rank(Acari, Acari$taxonRank) # NMNH species taxa
taxo_acari <- DwC2taxo(Acari, source = "UMZM") # transform to taxotool format
#sanity check
original <- nrow(Acari)
final <- nrow(taxo_acari) + nrow(Acari_ht)
ifelse(original == final, print("yay"),print("ugh"))
# if yay write out the taxo file
write.csv(df,"~/GitHub/tpt-acari/output/taxo_Acari.csv", row.names = FALSE) # taxo file
# read in files
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned Acari Darwin Core file
library(readxl)
library(data.table)
library(stringi)
library(taxotools)
library(dplyr)
# functions
# define function: name length
name_length <- function(x) ifelse(!is.na(x), length(unlist(strsplit(x, ' '))), 0)
# define function: is not in
'%!in%' <- function(x,y)!('%in%'(x,y))
# define function: right
right = function (string, char) {
substr(string,(unlist(lapply(gregexpr(pattern = char, string), min)) + 1),nchar(string))
}
# define function: left
left = function (string,char) {
substr(string,1,unlist(lapply(gregexpr(pattern = char, string), min)))
}
# define function: text to columns
text_to_columns <- function(dat, col, data="", column="", separator="", new_col_name_prefix="") { # dat is the data frame to operate on and col is the name of the column to be split
colno <- max(lengths(strsplit(col, separator))) # get max number of terms for any value in the column to be split
setDT(dat)[, paste0(new_col_name_prefix, 1:colno) := tstrsplit(col, separator)] # parse out terms into separate columns with column names prefixed with new_col_name_prefix plus consecutive numbers from 1 through colno
}
# function: remove '\xa0' chars
phrase_clean <- function(x) gsub("[\xA0]", "", x)
# function: replace double spaces with single spaces
space_clean <- function(x) gsub("  ", " ", x)
# function: get everything from INSIDE any parenthesis
inparens <- function(x)gsub("(?<=\\()[^()]*(?=\\))(*SKIP)(*F)|.", "", x, perl=T)
# function: get everything from OUTSIDE any parenthesis
outparens <- function(x){
trimws(gsub("\\([^()]*\\)", "", x))
}
# function: apply a function to ALL character columns
char_fun <- function(x,y){ # x = dataframe, y = function to apply
setDT(x)
cols_to_be_rectified <- names(x)[vapply(x, is.character, logical(1))]
x[,c(cols_to_be_rectified) := lapply(.SD, y), .SDcols = cols_to_be_rectified]
}
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*species.*', 'specificEpithet',x)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','author',x)
x <- gsub('.*year.*','namePublishedInYear',x)
x <- gsub('.*scientific.*','scientificName',x)
x
}
# define function: get higher taxa with epithets
higher_taxa_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(sp, name_length) == 0 &
lapply(spp, name_length) == 0),] # keep names where species and subspecies are blank
}
# define function: get higher taxa with rank
higher_taxa_rank <- function(dat, rank){ # dat is data frame, rank is column where taxon rank is given
dat[which(rank != "species" & # remove taxa ranked species
rank != "subspecies"),] # remove taxa ranked subspecies
}
# define function: get species with epithet
species_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(spp, name_length) != 0 | # keep taxa with a subspecies name
lapply(sp, name_length) != 0),] # keep taxa with a species name
}
# define function: get species with rank
species_rank <- function(dat, col){ # data is dataframe, col is column where rank is given
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),] # remove higher taxa from working file
dat[which(col == "species" | # keep taxa with rank species
col == "subspecies"),] # keep taxa ranked subspecies
}
Acari$taxonomicStatus <- NULL
# Acari$taxonomicStatus <- ifelse(is.na(Acari$taxonomicStatus),"undefined",NMNH$taxonomicStatus) # fill in taxonomic status
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # NMNH higher taxa
# Acari_species <- species_rank(Acari, Acari$taxonRank) # NMNH species taxa
taxo_acari <- DwC2taxo(Acari, source = "UMZM") # transform to taxotool format
GBIF <- read.csv("~/GitHub/tpt-acari/input/GBIF_acari.csv") # read in GBIF file
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # GBIF higher taxa
# GBIF_species <- species_rank(GBIF, GBIF$taxonRank) # GBIF species taxa
GBIF <- compact_ids(GBIF,id="taxonID",accid="acceptedNameUsageID") # deal with letters and long ids
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
#sanity check
original <- nrow(Acari) + nrow(GBIF)
final <- nrow(taxo_acari) + nrow(Acari_ht)
# Acari_species <- species_rank(Acari, Acari$taxonRank) # NMNH species taxa
Acari_taxo <- DwC2taxo(Acari, source = "TPT") # transform to taxotool format
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
#sanity check
original <- nrow(Acari) + nrow(GBIF)
final <- nrow(Acari_taxo) + nrow(Acari_ht) + nrow(GBIF_taxo) + nrow(GBIF_ht)
ifelse(original == final, print("yay"),print("ugh"))
# if ugh, find the problem
GBIF_not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in GBIF that do not match an id in taxo
problems <- GBIF_not_in_taxo[GBIF_not_in_taxo$taxonID %!in% GBIF_ht$taxonID,] # get all rows in above that do not match an id in GBIF_ht
View(problems)
# Mite_merge
Mite_m1 <- merge_lists(UMZM_taxo, GBIF_taxo) # master is UNMZ, merging with GBIF
# Mite_merge
Mite_m1 <- merge_lists(Acari_taxo, GBIF_taxo) # master is UNMZ, merging with GBIF
Mite_mast1 <- rbind.fill(UMZM_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
Mite_mast1 <- rbind.fill(Acari_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
Mite_mast1 <- rbind.fill(Acari_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
library(plyr)
Mite_mast1 <- rbind.fill(Acari_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
View(Mite_mast1)
Mite_mast1_1 <- cast_cs_field(Mite_mast1,"canonical","source")
View(Mite_mast1_1)
write.csv(df,"~/GitHub/tpt-acari/output/taxo_Acari.csv", row.names = FALSE) # taxo file
# if ugh, find the problem
merge_probs(GBIF, GBIF$taxonID, GBIF_taxo$id, GBIF_ht$taxonID)
# define function: find merge problems
merge_probs <- function(dat, datcol, taxocol, htcol){
not_in_taxo <- dat[datcol %!in% taxocol,] # get all rows in original data (dat) with (datcol) that does not match (taxocol)
problems <- not_in_taxo[not_in_taxo$taxonID %!in% htcol,] # get all rows in above that do not match  original higher geography (htcol)
}
# if ugh, find the problem
merge_probs(GBIF, GBIF$taxonID, GBIF_taxo$id, GBIF_ht$taxonID)
View(taxo_acari)
write.csv(Mite_mast1_1,"~/GitHub/tpt-acari/output/taxo_Acari.csv", row.names = FALSE) # taxo file
# Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo) # master is UNMZ, merging with GBIF
Mite_mast1 <- rbind.fill(GBIF_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
Mite_mast1_1 <- cast_cs_field(Mite_mast1,"canonical","source")
View(GBIF)
library(readxl)
library(data.table)
library(stringi)
library(taxotools)
library(dplyr)
library(plyr)
# functions
# define function: name length
name_length <- function(x) ifelse(!is.na(x), length(unlist(strsplit(x, ' '))), 0)
# define function: is not in
'%!in%' <- function(x,y)!('%in%'(x,y))
# define function: right
right = function (string, char) {
substr(string,(unlist(lapply(gregexpr(pattern = char, string), min)) + 1),nchar(string))
}
# define function: left
left = function (string,char) {
substr(string,1,unlist(lapply(gregexpr(pattern = char, string), min)))
}
# define function: text to columns
text_to_columns <- function(dat, col, data="", column="", separator="", new_col_name_prefix="") { # dat is the data frame to operate on and col is the name of the column to be split
colno <- max(lengths(strsplit(col, separator))) # get max number of terms for any value in the column to be split
setDT(dat)[, paste0(new_col_name_prefix, 1:colno) := tstrsplit(col, separator)] # parse out terms into separate columns with column names prefixed with new_col_name_prefix plus consecutive numbers from 1 through colno
}
# function: remove '\xa0' chars
phrase_clean <- function(x) gsub("[\xA0]", "", x)
# function: replace double spaces with single spaces
space_clean <- function(x) gsub("  ", " ", x)
# function: get everything from INSIDE any parenthesis
inparens <- function(x)gsub("(?<=\\()[^()]*(?=\\))(*SKIP)(*F)|.", "", x, perl=T)
# function: get everything from OUTSIDE any parenthesis
outparens <- function(x){
trimws(gsub("\\([^()]*\\)", "", x))
}
# function: apply a function to ALL character columns
char_fun <- function(x,y){ # x = dataframe, y = function to apply
setDT(x)
cols_to_be_rectified <- names(x)[vapply(x, is.character, logical(1))]
x[,c(cols_to_be_rectified) := lapply(.SD, y), .SDcols = cols_to_be_rectified]
}
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*species.*', 'specificEpithet',x)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','author',x)
x <- gsub('.*year.*','namePublishedInYear',x)
x <- gsub('.*scientific.*','scientificName',x)
x
}
# define function: get higher taxa with epithets
higher_taxa_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(sp, name_length) == 0 &
lapply(spp, name_length) == 0),] # keep names where species and subspecies are blank
}
# define function: get higher taxa with rank
higher_taxa_rank <- function(dat, rank){ # dat is data frame, rank is column where taxon rank is given
dat[which(rank != "species" & # remove taxa ranked species
rank != "subspecies"),] # remove taxa ranked subspecies
}
# define function: get species with epithet
species_epithet <- function(dat, sp, spp){ # data is data frame, sp is column where species is given, spp is column where subspecies is given
dat[which(lapply(spp, name_length) != 0 | # keep taxa with a subspecies name
lapply(sp, name_length) != 0),] # keep taxa with a species name
}
# define function: get species with rank
species_rank <- function(dat, col){ # data is dataframe, col is column where rank is given
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),] # remove higher taxa from working file
dat[which(col == "species" | # keep taxa with rank species
col == "subspecies"),] # keep taxa ranked subspecies
}
# define function: find merge problems
merge_probs <- function(dat, datcol, taxocol, htcol){
not_in_taxo <- dat[datcol %!in% taxocol,] # get all rows in original data (dat) with (datcol) that does not match (taxocol)
problems <- not_in_taxo[not_in_taxo$taxonID %!in% htcol,] # get all rows in above that do not match  original higher geography (htcol)
}
# read in files
Acari <- read.csv("~/GitHub/tpt-acari/output/Acari_DwC.csv", na = "NA") # read in cleaned Acari Darwin Core file
Acari$taxonomicStatus <- NULL
# Acari$taxonomicStatus <- ifelse(is.na(Acari$taxonomicStatus),"undefined",NMNH$taxonomicStatus) # fill in taxonomic status
Acari_ht <- higher_taxa_rank(Acari, Acari$taxonRank) # NMNH higher taxa
# Acari_species <- species_rank(Acari, Acari$taxonRank) # NMNH species taxa
Acari_taxo <- DwC2taxo(Acari, source = "TPT") # transform to taxotool format
GBIF <- read.csv("~/GitHub/tpt-acari/input/GBIF_acari.csv") # read in GBIF file
GBIF <- GBIF[which(lapply(GBIF$familyy))]
GBIF$taxonomicStatus <- ifelse(GBIF$taxonomicStatus == "homotypic synonym", "homotypicSynonym",
ifelse(GBIF$taxonomicStatus == "heterotypic synonym", "heterotypicSynonym", GBIF$taxonomicStatus)) # replace non-conforming status
GBIF <- read.csv("~/GitHub/tpt-acari/input/GBIF_acari.csv") # read in GBIF file
GBIF_ht <- higher_taxa_rank(GBIF, GBIF$taxonRank) # GBIF higher taxa
# GBIF_species <- species_rank(GBIF, GBIF$taxonRank) # GBIF species taxa
# GBIF <- compact_ids(GBIF,id="taxonID",accid="acceptedNameUsageID") # deal with letters and long ids
GBIF_taxo <- DwC2taxo(GBIF, source = "GBIF") # transform to taxo format
#sanity check
original <- nrow(Acari) + nrow(GBIF)
final <- nrow(Acari_taxo) + nrow(Acari_ht) + nrow(GBIF_taxo) + nrow(GBIF_ht)
ifelse(original == final, print("yay"),print("ugh"))
# if ugh, find the problem
merge_probs(GBIF, GBIF$taxonID, GBIF_taxo$id, GBIF_ht$taxonID)
View(GBIF)
View(GBIF_taxo)
# if ugh, find the problem
merge_probs(GBIF, GBIF$taxonID, GBIF_taxo$id, GBIF_ht$taxonID)
# if ugh, find the problem
# merge_probs(GBIF, GBIF$taxonID, GBIF_taxo$id, GBIF_ht$taxonID)
not_in_taxo <- GBIF[GBIF$taxonID %!in% GBIF_taxo$id,] # get all rows in original data (dat) with (datcol) that does not match (taxocol)
problems <- not_in_taxo[not_in_taxo$taxonID %!in% GBIF_ht$taxonID,] # get all rows in above that do not match  original higher geography (htcol)
View(problems)
# Mite_merge
Mite_m1 <- merge_lists(GBIF_taxo, Acari_taxo) # master is UNMZ, merging with GBIF
Mite_mast1 <- rbind.fill(GBIF_taxo,Mite_m1$addlist,Mite_m1$noaddlist)
Mite_mast1_1 <- cast_cs_field(Mite_mast1,"canonical","source")
