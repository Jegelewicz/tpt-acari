# df <- df[-which(apply(df,1,function(x)all(is.na(x)))),] # remove empty rows
original_rows <- nrow(df)
tpt_dwc_template <- read_excel("input/tpt_dwc_template.xlsx") # read in TPT DarwinCore template
tpt_dwc_template[] <- lapply(tpt_dwc_template, as.character) # set all columns in template to character
# transform column headers
colnames(df) <- tolower(colnames(df)) # lower case column names
View(tpt_dwc_template)
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','scientificNameAuthorship',x)
x
}
colnames(df) <- convert2DwC(colnames(df)) # convert to DarwinCore terms
View(df)
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','scientificNameAuthorship',x)
x <- gsub('.*species.*','specificEpithet',x)
x
}
colnames(df) <- convert2DwC(colnames(df)) # convert to DarwinCore terms
df <- rbindlist(list(df, tpt_dwc_template), fill = TRUE) # add all DwC columns
library(readxl)
library(data.table)
library(stringi)
library(taxotools)
# define function: name length
name_length <- function(x) ifelse(!is.na(x), length(unlist(strsplit(x, ' '))), 0)
# define function: is not in
'%!in%' <- function(x,y)!('%in%'(x,y))
# define right function
right = function (string, char) {
substr(string,(char + 1),nchar(string))
}
# define left function
left = function (string,char) {
substr(string,1,char - 1)
}
df <- rbindlist(list(df, tpt_dwc_template), fill = TRUE) # add all DwC columns
df$TPTdataset <- "UMZM" # add dataset name
df$TPTID <- seq.int(nrow(df)) # add numeric ID for each name
df$kingdom <- "Animalia" # add kingdom
df$phylum <- "Arthropoda" # add phylum
# clean up
# define function: remove '\xa0' chars and non-conforming punctuation
phrase_clean <- function(x) gsub("[^[:alnum:][:blank:]&,()];", "", x)
space_clean <- function(x) gsub("  ", " ", x)
# remove remove '\xa0' chars
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, phrase_clean), .SDcols = cols_to_be_rectified]
# strip spaces from ends of strings
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, trimws), .SDcols = cols_to_be_rectified]
# strip double spaces
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, space_clean), .SDcols = cols_to_be_rectified]
# split specificEpithet when it has two terms
multi_epithet <- df[which(lapply(df$species, name_length) > 1),] # extract rows with a multi-name specifies
df <- df[which(lapply(df$species, name_length) <= 1),] # extract rows with a multi-name specifies
for(i in 1:nrow(multi_epithet)){
multi_epithet$specificEpithet[i] <- left(multi_epithet$species[i], unlist(gregexpr(pattern = " ", multi_epithet$species[i]))) # place first term in specificEpithet
multi_epithet$infraspecificEpithet[i] <- right(multi_epithet$species[i], unlist(gregexpr(pattern = " ", multi_epithet$species[i]))) # place second term in infraspecificEpithet
}
df <- mite_may_2020 # change filename for ease of use
# df <- df[-which(apply(df,1,function(x)all(is.na(x)))),] # remove empty rows
original_rows <- nrow(df)
tpt_dwc_template <- read_excel("input/tpt_dwc_template.xlsx") # read in TPT DarwinCore template
tpt_dwc_template[] <- lapply(tpt_dwc_template, as.character) # set all columns in template to character
# transform column headers
colnames(df) <- tolower(colnames(df)) # lower case column names
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','scientificNameAuthorship',x)
x <- gsub('.*species.*','specificEpithet',x)
x
}
colnames(df) <- convert2DwC(colnames(df)) # convert to DarwinCore terms
df <- rbindlist(list(df, tpt_dwc_template), fill = TRUE) # add all DwC columns
df$TPTdataset <- "UMZM" # add dataset name
df$TPTID <- seq.int(nrow(df)) # add numeric ID for each name
df$kingdom <- "Animalia" # add kingdom
df$phylum <- "Arthropoda" # add phylum
# clean up
# define function: remove '\xa0' chars and non-conforming punctuation
phrase_clean <- function(x) gsub("[^[:alnum:][:blank:]&,()];", "", x)
space_clean <- function(x) gsub("  ", " ", x)
# remove remove '\xa0' chars
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, phrase_clean), .SDcols = cols_to_be_rectified]
# strip spaces from ends of strings
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, trimws), .SDcols = cols_to_be_rectified]
# strip double spaces
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, space_clean), .SDcols = cols_to_be_rectified]
# split specificEpithet when it has two terms
multi_epithet <- df[which(lapply(df$specificEpithet, name_length) > 1),] # extract rows with a multi-name specifies
# cast canonical name
# extract rows with canonicalName
df$canonicalName <- NA # create column for canonicalName
canonical <- df[which(lapply(df$canonicalName, name_length) != 0),] # remove rows with canonical elsewhere
df <- df[which(lapply(df$canonicalName, name_length) == 0),] # retain only rows with no canonical
# extract higher taxa for next set of review
higher_taxa <- df[which(lapply(df$infraspecificEpithet, name_length) == 0 & lapply(df$specificEpithet, name_length) == 0),]
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),]
# generate canonical name for genus and below
df <- cast_canonical(df,
canonical="canonicalName",
genus = "genus",
species = "specificEpithet",
subspecies = "infraspecificEpithet")
# generate taxonRank for genus and below
for(i in 1:nrow(df)){
df$taxonRank[i] <-
ifelse(!is.na(df$infraspecificEpithet[i]), "subspecies",
ifelse(!is.na(df$specificEpithet[i]), "species",
"review"))
}
View(higher_taxa)
View(higher_taxa)
# canonical names for taxa ranked subgenus and above - get the lowest ranking term and put it here!
for(i in 1:nrow(higher_taxa)){
higher_taxa$canonicalName[i] <- ifelse(!is.na(higher_taxa$subgenus[i]), paste(higher_taxa$subgenus[i]),
ifelse(!is.na(higher_taxa$genus[i]), paste(higher_taxa$genus[i]),
ifelse(!is.na(higher_taxa$subtribe[i]), paste(higher_taxa$subtribe[i]),
ifelse(!is.na(higher_taxa$tribe[i]), paste(higher_taxa$tribe[i]),
ifelse(!is.na(higher_taxa$subfamily[i]), paste(higher_taxa$subfamily[i]),
ifelse(!is.na(higher_taxa$family[i]), paste(higher_taxa$family[i]),
ifelse(!is.na(higher_taxa$superfamily[i]), paste(higher_taxa$superfamily[i]),
ifelse(!is.na(higher_taxa$infraorder[i]), paste(higher_taxa$infraorder[i]),
ifelse(!is.na(higher_taxa$order[i]), paste(higher_taxa$order[i]),
ifelse(!is.na(higher_taxa$class[i]), paste(higher_taxa$class[i]),
ifelse(!is.na(higher_taxa$phylum[i]), paste(higher_taxa$phylum[i]),
ifelse(!is.na(higher_taxa$kingdom[i]), paste(higher_taxa$kingdom[i]), "review"))))))))))))
}
df <- mite_may_2020 # change filename for ease of use
# df <- df[-which(apply(df,1,function(x)all(is.na(x)))),] # remove empty rows
original_rows <- nrow(df)
tpt_dwc_template <- read_excel("input/tpt_dwc_template.xlsx") # read in TPT DarwinCore template
tpt_dwc_template[] <- lapply(tpt_dwc_template, as.character) # set all columns in template to character
# transform column headers
colnames(df) <- tolower(colnames(df)) # lower case column names
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','scientificNameAuthorship',x)
x <- gsub('.*species.*','specificEpithet',x)
x
}
colnames(df) <- convert2DwC(colnames(df)) # convert to DarwinCore terms
df <- rbindlist(list(df, tpt_dwc_template), fill = TRUE) # add all DwC columns
df$TPTdataset <- "UMZM" # add dataset name
df$TPTID <- seq.int(nrow(df)) # add numeric ID for each name
df$kingdom <- "Animalia" # add kingdom
df$phylum <- "Arthropoda" # add phylum
# clean up
# define function: remove '\xa0' chars and non-conforming punctuation
phrase_clean <- function(x) gsub("[^[:alnum:][:blank:]&,()];", "", x)
space_clean <- function(x) gsub("  ", " ", x)
# remove remove '\xa0' chars
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, phrase_clean), .SDcols = cols_to_be_rectified]
# strip spaces from ends of strings
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, trimws), .SDcols = cols_to_be_rectified]
# strip double spaces
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, space_clean), .SDcols = cols_to_be_rectified]
# split specificEpithet when it has two terms
multi_epithet <- df[which(lapply(df$specificEpithet, name_length) > 1),] # extract rows with a multi-name specifies
# cast canonical name
# extract rows with canonicalName
df$canonicalName <- NA # create column for canonicalName
canonical <- df[which(lapply(df$canonicalName, name_length) != 0),] # remove rows with canonical elsewhere
df <- df[which(lapply(df$canonicalName, name_length) == 0),] # retain only rows with no canonical
# extract higher taxa for next set of review
higher_taxa <- df[which(lapply(df$infraspecificEpithet, name_length) == 0 & lapply(df$specificEpithet, name_length) == 0),]
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),]
# generate canonical name for genus and below
df <- cast_canonical(df,
canonical="canonicalName",
genus = "genus",
species = "specificEpithet",
subspecies = "infraspecificEpithet")
# generate taxonRank for genus and below
for(i in 1:nrow(df)){
df$taxonRank[i] <-
ifelse(!is.na(df$infraspecificEpithet[i]), "subspecies",
ifelse(!is.na(df$specificEpithet[i]), "species",
"review"))
}
# canonical names for taxa ranked subgenus and above - get the lowest ranking term and put it here!
for(i in 1:nrow(higher_taxa)){
higher_taxa$canonicalName[i] <- ifelse(!is.na(higher_taxa$subgenus[i]), paste(higher_taxa$subgenus[i]),
ifelse(!is.na(higher_taxa$genus[i]), paste(higher_taxa$genus[i]),
ifelse(!is.na(higher_taxa$subtribe[i]), paste(higher_taxa$subtribe[i]),
ifelse(!is.na(higher_taxa$tribe[i]), paste(higher_taxa$tribe[i]),
ifelse(!is.na(higher_taxa$subfamily[i]), paste(higher_taxa$subfamily[i]),
ifelse(!is.na(higher_taxa$family[i]), paste(higher_taxa$family[i]),
ifelse(!is.na(higher_taxa$superfamily[i]), paste(higher_taxa$superfamily[i]),
ifelse(!is.na(higher_taxa$hyporder[i]), paste(higher_taxa$hyporder[i]),
ifelse(!is.na(higher_taxa$infraorder[i]), paste(higher_taxa$infraorder[i]),
ifelse(!is.na(higher_taxa$suborder[i]), paste(higher_taxa$suborder[i]),
ifelse(!is.na(higher_taxa$order[i]), paste(higher_taxa$order[i]),
ifelse(!is.na(higher_taxa$superorder[i]), paste(higher_taxa$superorder[i]),
ifelse(!is.na(higher_taxa$subclass[i]), paste(higher_taxa$subclass[i]),
ifelse(!is.na(higher_taxa$class[i]), paste(higher_taxa$class[i]),
ifelse(!is.na(higher_taxa$phylum[i]), paste(higher_taxa$phylum[i]),
ifelse(!is.na(higher_taxa$kingdom[i]), paste(higher_taxa$kingdom[i]), "review"))))))))))))))))
}
# generate taxonRank for genus and above
for(i in 1:nrow(higher_taxa)){
higher_taxa$taxonRank[i] <-
ifelse(!is.na(higher_taxa$subgenus[i]), "subgenus",
ifelse(!is.na(higher_taxa$genus[i]), "genus",
ifelse(!is.na(higher_taxa$subtribe[i]), "subtribe",
ifelse(!is.na(higher_taxa$tribe[i]), "tribe",
ifelse(!is.na(higher_taxa$subfamily[i]), "subfamily",
ifelse(!is.na(higher_taxa$family[i]), "family",
ifelse(!is.na(higher_taxa$superfamily[i]), "superfamily",
ifelse(!is.na(higher_taxa$hyporder[i]), "hyporder",
ifelse(!is.na(higher_taxa$infraorder[i]), "infraorder",
ifelse(!is.na(higher_taxa$suborder[i]), "suborder",
ifelse(!is.na(higher_taxa$order[i]), "order",
ifelse(!is.na(higher_taxa$superorder[i]), "superorder",
ifelse(!is.na(higher_taxa$subclass[i]), "subclass",
ifelse(!is.na(higher_taxa$class[i]), "class",
ifelse(!is.na(higher_taxa$phylum[i]), "phylum",
ifelse(!is.na(higher_taxa$kingdom[i]), "kingdom",
"review")))))))))))))))))
}
# generate taxonRank for genus and above
for(i in 1:nrow(higher_taxa)){
higher_taxa$taxonRank[i] <-
ifelse(!is.na(higher_taxa$subgenus[i]), "subgenus",
ifelse(!is.na(higher_taxa$genus[i]), "genus",
ifelse(!is.na(higher_taxa$subtribe[i]), "subtribe",
ifelse(!is.na(higher_taxa$tribe[i]), "tribe",
ifelse(!is.na(higher_taxa$subfamily[i]), "subfamily",
ifelse(!is.na(higher_taxa$family[i]), "family",
ifelse(!is.na(higher_taxa$superfamily[i]), "superfamily",
ifelse(!is.na(higher_taxa$hyporder[i]), "hyporder",
ifelse(!is.na(higher_taxa$infraorder[i]), "infraorder",
ifelse(!is.na(higher_taxa$suborder[i]), "suborder",
ifelse(!is.na(higher_taxa$order[i]), "order",
ifelse(!is.na(higher_taxa$superorder[i]), "superorder",
ifelse(!is.na(higher_taxa$subclass[i]), "subclass",
ifelse(!is.na(higher_taxa$class[i]), "class",
ifelse(!is.na(higher_taxa$phylum[i]), "phylum",
ifelse(!is.na(higher_taxa$kingdom[i]), "kingdom",
"review"))))))))))))))))
}
# Extract rows from higher taxa that need review
flag <- c('review')
review_canonical <- higher_taxa[(higher_taxa$canonical %in% flag), ]
df <- rbind(higher_taxa, df) # add higher taxa back to df for remainder of de-duplication
df <- mite_may_2020 # change filename for ease of use
# df <- df[-which(apply(df,1,function(x)all(is.na(x)))),] # remove empty rows
original_rows <- nrow(df)
tpt_dwc_template <- read_excel("input/tpt_dwc_template.xlsx") # read in TPT DarwinCore template
tpt_dwc_template[] <- lapply(tpt_dwc_template, as.character) # set all columns in template to character
# transform column headers
colnames(df) <- tolower(colnames(df)) # lower case column names
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','scientificNameAuthorship',x)
x <- gsub('.*species.*','specificEpithet',x)
x
}
colnames(df) <- convert2DwC(colnames(df)) # convert to DarwinCore terms
df <- rbindlist(list(df, tpt_dwc_template), fill = TRUE) # add all DwC columns
df$TPTdataset <- "UMZM" # add dataset name
df$TPTID <- seq.int(nrow(df)) # add numeric ID for each name
df$kingdom <- "Animalia" # add kingdom
df$phylum <- "Arthropoda" # add phylum
# clean up
# define function: remove '\xa0' chars and non-conforming punctuation
phrase_clean <- function(x) gsub("[^[:alnum:][:blank:]&,()];", "", x)
space_clean <- function(x) gsub("  ", " ", x)
# remove remove '\xa0' chars
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, phrase_clean), .SDcols = cols_to_be_rectified]
# strip spaces from ends of strings
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, trimws), .SDcols = cols_to_be_rectified]
# strip double spaces
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, space_clean), .SDcols = cols_to_be_rectified]
# split specificEpithet when it has two terms
multi_epithet <- df[which(lapply(df$specificEpithet, name_length) > 1),] # extract rows with a multi-name specifies
# cast canonical name
# extract rows with canonicalName
df$canonicalName <- NA # create column for canonicalName
canonical <- df[which(lapply(df$canonicalName, name_length) != 0),] # remove rows with canonical elsewhere
# extract higher taxa for next set of review
higher_taxa <- df[which(lapply(df$infraspecificEpithet, name_length) == 0 & lapply(df$specificEpithet, name_length) == 0),]
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),]
# generate canonical name for species and below
df <- cast_canonical(df,
canonical="canonicalName",
genus = "genus",
species = "specificEpithet",
subspecies = "infraspecificEpithet")
# generate taxonRank for species and below
for(i in 1:nrow(df)){
df$taxonRank[i] <-
ifelse(!is.na(df$infraspecificEpithet[i]), "subspecies",
ifelse(!is.na(df$specificEpithet[i]), "species",
"review"))
}
# canonical names for taxa ranked subgenus and above - get the lowest ranking term and put it here!
for(i in 1:nrow(higher_taxa)){
higher_taxa$canonicalName[i] <- ifelse(!is.na(higher_taxa$subgenus[i]), paste(higher_taxa$subgenus[i]),
ifelse(!is.na(higher_taxa$genus[i]), paste(higher_taxa$genus[i]),
ifelse(!is.na(higher_taxa$subtribe[i]), paste(higher_taxa$subtribe[i]),
ifelse(!is.na(higher_taxa$tribe[i]), paste(higher_taxa$tribe[i]),
ifelse(!is.na(higher_taxa$subfamily[i]), paste(higher_taxa$subfamily[i]),
ifelse(!is.na(higher_taxa$family[i]), paste(higher_taxa$family[i]),
ifelse(!is.na(higher_taxa$superfamily[i]), paste(higher_taxa$superfamily[i]),
ifelse(!is.na(higher_taxa$hyporder[i]), paste(higher_taxa$hyporder[i]),
ifelse(!is.na(higher_taxa$infraorder[i]), paste(higher_taxa$infraorder[i]),
ifelse(!is.na(higher_taxa$suborder[i]), paste(higher_taxa$suborder[i]),
ifelse(!is.na(higher_taxa$order[i]), paste(higher_taxa$order[i]),
ifelse(!is.na(higher_taxa$superorder[i]), paste(higher_taxa$superorder[i]),
ifelse(!is.na(higher_taxa$subclass[i]), paste(higher_taxa$subclass[i]),
ifelse(!is.na(higher_taxa$class[i]), paste(higher_taxa$class[i]),
ifelse(!is.na(higher_taxa$phylum[i]), paste(higher_taxa$phylum[i]),
ifelse(!is.na(higher_taxa$kingdom[i]), paste(higher_taxa$kingdom[i]), "review"))))))))))))))))
}
# generate taxonRank for subgenus and above
for(i in 1:nrow(higher_taxa)){
higher_taxa$taxonRank[i] <-
ifelse(!is.na(higher_taxa$subgenus[i]), "subgenus",
ifelse(!is.na(higher_taxa$genus[i]), "genus",
ifelse(!is.na(higher_taxa$subtribe[i]), "subtribe",
ifelse(!is.na(higher_taxa$tribe[i]), "tribe",
ifelse(!is.na(higher_taxa$subfamily[i]), "subfamily",
ifelse(!is.na(higher_taxa$family[i]), "family",
ifelse(!is.na(higher_taxa$superfamily[i]), "superfamily",
ifelse(!is.na(higher_taxa$hyporder[i]), "hyporder",
ifelse(!is.na(higher_taxa$infraorder[i]), "infraorder",
ifelse(!is.na(higher_taxa$suborder[i]), "suborder",
ifelse(!is.na(higher_taxa$order[i]), "order",
ifelse(!is.na(higher_taxa$superorder[i]), "superorder",
ifelse(!is.na(higher_taxa$subclass[i]), "subclass",
ifelse(!is.na(higher_taxa$class[i]), "class",
ifelse(!is.na(higher_taxa$phylum[i]), "phylum",
ifelse(!is.na(higher_taxa$kingdom[i]), "kingdom",
"review"))))))))))))))))
}
# cast scientific name for species and below
df$scientificName[i] <- for(i in 1:nrow(df)){
if(!is.na(df$genus[i])){
scn <- df$genus[i]
}
if(!is.na(df$subgenus[i])){
scn <- paste(scn," (",df$subgenus[i],")",sep = "")
}
if(!is.na(df$specificEpithet[i])){
scn <- paste(scn,df$specificEpithet[i], sep = " ")
}
if(!is.na(df$infraspecificEpithet[i])){
scn <- paste(scn,df$infraspecificEpithet[i], sep = " ")
}
if(!is.na(df$scientificNameAuthorship[i])){
scn <- paste(scn,trimws(df$scientificNameAuthorship[i]), sep = " ")
}
df$scientificName[i] <- scn
}
# cast scientific name for genus and above
higher_taxa$scientificName <- paste0(higher_taxa$canonicalName, higher_taxa$scientificNameAuthorship, sep = " ")
df <- mite_may_2020 # change filename for ease of use
# df <- df[-which(apply(df,1,function(x)all(is.na(x)))),] # remove empty rows
original_rows <- nrow(df)
tpt_dwc_template <- read_excel("input/tpt_dwc_template.xlsx") # read in TPT DarwinCore template
tpt_dwc_template[] <- lapply(tpt_dwc_template, as.character) # set all columns in template to character
# transform column headers
colnames(df) <- tolower(colnames(df)) # lower case column names
# define DwC conversion
convert2DwC <- function(df_colname) {
x <- gsub('.*subspecies.*','infraspecificEpithet',df_colname)
x <- gsub('.*rank.*','taxonRank',x)
x <- gsub('.*author.*','scientificNameAuthorship',x)
x <- gsub('.*species.*','specificEpithet',x)
x
}
colnames(df) <- convert2DwC(colnames(df)) # convert to DarwinCore terms
df <- rbindlist(list(df, tpt_dwc_template), fill = TRUE) # add all DwC columns
df$TPTdataset <- "UMZM" # add dataset name
df$TPTID <- seq.int(nrow(df)) # add numeric ID for each name
df$kingdom <- "Animalia" # add kingdom
df$phylum <- "Arthropoda" # add phylum
# clean up
# define function: remove '\xa0' chars and non-conforming punctuation
phrase_clean <- function(x) gsub("[^[:alnum:][:blank:]&,()];", "", x)
space_clean <- function(x) gsub("  ", " ", x)
# remove remove '\xa0' chars
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, phrase_clean), .SDcols = cols_to_be_rectified]
# strip spaces from ends of strings
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, trimws), .SDcols = cols_to_be_rectified]
# strip double spaces
setDT(df)
cols_to_be_rectified <- names(df)[vapply(df, is.character, logical(1))]
df[,c(cols_to_be_rectified) := lapply(.SD, space_clean), .SDcols = cols_to_be_rectified]
# split specificEpithet when it has two terms
multi_epithet <- df[which(lapply(df$specificEpithet, name_length) > 1),] # extract rows with a multi-name specifies
# extract higher taxa for next set of review
higher_taxa <- df[which(lapply(df$infraspecificEpithet, name_length) == 0 & lapply(df$specificEpithet, name_length) == 0),]
df <- df[which(lapply(df$infraspecificEpithet, name_length) != 0 | lapply(df$specificEpithet, name_length) != 0),]
# generate canonical name for species and below
df <- cast_canonical(df,
canonical="canonicalName",
genus = "genus",
species = "specificEpithet",
subspecies = "infraspecificEpithet")
# generate taxonRank for species and below
for(i in 1:nrow(df)){
df$taxonRank[i] <-
ifelse(!is.na(df$infraspecificEpithet[i]), "subspecies",
ifelse(!is.na(df$specificEpithet[i]), "species",
"review"))
}
# canonical names for taxa ranked subgenus and above - get the lowest ranking term and put it here!
for(i in 1:nrow(higher_taxa)){
higher_taxa$canonicalName[i] <- ifelse(!is.na(higher_taxa$subgenus[i]), paste(higher_taxa$subgenus[i]),
ifelse(!is.na(higher_taxa$genus[i]), paste(higher_taxa$genus[i]),
ifelse(!is.na(higher_taxa$subtribe[i]), paste(higher_taxa$subtribe[i]),
ifelse(!is.na(higher_taxa$tribe[i]), paste(higher_taxa$tribe[i]),
ifelse(!is.na(higher_taxa$subfamily[i]), paste(higher_taxa$subfamily[i]),
ifelse(!is.na(higher_taxa$family[i]), paste(higher_taxa$family[i]),
ifelse(!is.na(higher_taxa$superfamily[i]), paste(higher_taxa$superfamily[i]),
ifelse(!is.na(higher_taxa$hyporder[i]), paste(higher_taxa$hyporder[i]),
ifelse(!is.na(higher_taxa$infraorder[i]), paste(higher_taxa$infraorder[i]),
ifelse(!is.na(higher_taxa$suborder[i]), paste(higher_taxa$suborder[i]),
ifelse(!is.na(higher_taxa$order[i]), paste(higher_taxa$order[i]),
ifelse(!is.na(higher_taxa$superorder[i]), paste(higher_taxa$superorder[i]),
ifelse(!is.na(higher_taxa$subclass[i]), paste(higher_taxa$subclass[i]),
ifelse(!is.na(higher_taxa$class[i]), paste(higher_taxa$class[i]),
ifelse(!is.na(higher_taxa$phylum[i]), paste(higher_taxa$phylum[i]),
ifelse(!is.na(higher_taxa$kingdom[i]), paste(higher_taxa$kingdom[i]), "review"))))))))))))))))
}
# generate taxonRank for subgenus and above
for(i in 1:nrow(higher_taxa)){
higher_taxa$taxonRank[i] <-
ifelse(!is.na(higher_taxa$subgenus[i]), "subgenus",
ifelse(!is.na(higher_taxa$genus[i]), "genus",
ifelse(!is.na(higher_taxa$subtribe[i]), "subtribe",
ifelse(!is.na(higher_taxa$tribe[i]), "tribe",
ifelse(!is.na(higher_taxa$subfamily[i]), "subfamily",
ifelse(!is.na(higher_taxa$family[i]), "family",
ifelse(!is.na(higher_taxa$superfamily[i]), "superfamily",
ifelse(!is.na(higher_taxa$hyporder[i]), "hyporder",
ifelse(!is.na(higher_taxa$infraorder[i]), "infraorder",
ifelse(!is.na(higher_taxa$suborder[i]), "suborder",
ifelse(!is.na(higher_taxa$order[i]), "order",
ifelse(!is.na(higher_taxa$superorder[i]), "superorder",
ifelse(!is.na(higher_taxa$subclass[i]), "subclass",
ifelse(!is.na(higher_taxa$class[i]), "class",
ifelse(!is.na(higher_taxa$phylum[i]), "phylum",
ifelse(!is.na(higher_taxa$kingdom[i]), "kingdom",
"review"))))))))))))))))
}
# cast scientific name for species and below
df$scientificName[i] <- for(i in 1:nrow(df)){
if(!is.na(df$genus[i])){
scn <- df$genus[i]
}
if(!is.na(df$subgenus[i])){
scn <- paste(scn," (",df$subgenus[i],")",sep = "")
}
if(!is.na(df$specificEpithet[i])){
scn <- paste(scn,df$specificEpithet[i], sep = " ")
}
if(!is.na(df$infraspecificEpithet[i])){
scn <- paste(scn,df$infraspecificEpithet[i], sep = " ")
}
if(!is.na(df$scientificNameAuthorship[i])){
scn <- paste(scn,trimws(df$scientificNameAuthorship[i]), sep = " ")
}
df$scientificName[i] <- scn
}
# cast scientific name for genus and above
higher_taxa$scientificName <- ifelse(is.na(higher_taxon$scientificNameAuthorship), higher_taxon$canonicalName, paste0(higher_taxa$canonicalName, higher_taxa$scientificNameAuthorship, sep = " "))
# cast scientific name for genus and above
higher_taxa$scientificName <- ifelse(is.na(higher_taxa$scientificNameAuthorship), higher_taxa$canonicalName, paste0(higher_taxa$canonicalName, higher_taxa$scientificNameAuthorship, sep = " "))
# cast scientific name for genus and above
higher_taxa$scientificName <- ifelse(is.na(higher_taxa$scientificNameAuthorship), higher_taxa$canonicalName, paste(higher_taxa$canonicalName, higher_taxa$scientificNameAuthorship, sep = " "))
